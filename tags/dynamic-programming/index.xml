<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dynamic Programming on Cindy&#39;s Blog</title>
    <link>http://xmxiaohuilin.github.io/tags/dynamic-programming/</link>
    <description>Recent content in Dynamic Programming on Cindy&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>(c) 2015 Cindy Lin.</copyright>
    <lastBuildDate>Thu, 19 Nov 2015 14:43:13 -0700</lastBuildDate>
    <atom:link href="http://xmxiaohuilin.github.io/tags/dynamic-programming/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Longest Palindromic Substring</title>
      <link>http://xmxiaohuilin.github.io/2015/11/19/longest-palindromic-substring/</link>
      <pubDate>Thu, 19 Nov 2015 14:43:13 -0700</pubDate>
      
      <guid>http://xmxiaohuilin.github.io/2015/11/19/longest-palindromic-substring/</guid>
      <description>

&lt;p&gt;Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given the string = &lt;code&gt;&amp;quot;abcdzdcab&amp;quot;&lt;/code&gt;, return &lt;code&gt;&amp;quot;cdzdc&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n2) time is acceptable. Can you do it in O(n) time.&lt;/p&gt;

&lt;h2 id=&#34;think-2&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;One pass on each position in string characters, assume the axis of symmetry on each character or between two character:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    |                       |
c a b a c f     or     c a b a c f
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;On each axis of symmetry we get the left and right pointers and make them move toward left or right&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;left right           
   \ /                 
c a b a c f 

...or...        

    l r
    | |
c a b a c f
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param s input string
     * @return the longest palindromic substring
     */
    private String LongestPalindromeSubstringI(String str) {
        int maxLen = 0;
        String maxSubstr = &amp;quot;&amp;quot;;
        // memorized whether it is palindromical in str (i, j)
        boolean[][] memo = new boolean[str.length()][str.length()];
        for (int i = str.length() - 1; i &amp;gt;= 0; i--) {
            for (int j = i; j &amp;lt; str.length(); j++) {
                if ((j - i &amp;lt; 2 || memo[i + 1][j - 1])
                        &amp;amp;&amp;amp; str.charAt(i) == str.charAt(j)) {
                    memo[i][j] = true;
                    if (j - i + 1 &amp;gt; maxLen) {
                        maxSubstr = str.substring(i, j + 1);
                        maxLen = j - i + 1;
                    }
                }
            }
        }
        return maxSubstr;
    }

    private String LongestPalindromeSubstringII(String str) {
        if(str == null || str.length() == 0)
            return &amp;quot;&amp;quot;;
        // record current longest length
        int maxLen = 0;
        String maxSubstr = &amp;quot;&amp;quot;;
        for (int i = 0; i &amp;lt; str.length(); i++) {
            // find the longest palindrome, when symmetry axis is the current index
            String case1 = expandFromCenter(str, i, i);
            // find the longest palindrome, when symmetry axis is between the current index and next index
            String case2 = expandFromCenter(str, i, i + 1);
            
            if (Math.max(case1.length(), case2.length()) &amp;gt; maxLen) {
                maxLen = Math.max(case1.length(), case2.length());
                maxSubstr = case1.length() &amp;gt; case2.length() ? case1 : case2;
            }
        }
        return maxSubstr;
    }

    private String expandFromCenter(String str, int left, int right) {
        // expand the left and right index two opposite sides
        while ( left &amp;gt;= 0
                &amp;amp;&amp;amp; right &amp;lt; str.length()&amp;amp;&amp;amp;str.charAt(left) == str.charAt(right)) {
            left--;
            right++;
        }
        return str.substring(left + 1, right);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;analysis&#34;&gt;Analysis&lt;/h2&gt;

&lt;p&gt;One pass from 0 - $$len \times 2$$; inside the loop the palindromic substring search also costs a loop from l - r; So the total is O($$n^2$$);&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Longest Palindromic Subsequence</title>
      <link>http://xmxiaohuilin.github.io/2015/11/15/longest-palindromic-subsequence/</link>
      <pubDate>Sun, 15 Nov 2015 14:43:13 -0700</pubDate>
      
      <guid>http://xmxiaohuilin.github.io/2015/11/15/longest-palindromic-subsequence/</guid>
      <description>

&lt;p&gt;Given a sequence, find the length of the longest palindromic subsequence in it. For example, if the given sequence is &lt;code&gt;“BBABCBCAB”&lt;/code&gt;, then the output should be 7 as &lt;code&gt;“BABCBAB”&lt;/code&gt; is the longest palindromic subseuqnce in it. &lt;code&gt;“BBBBB”&lt;/code&gt; and &lt;code&gt;“BBCBB”&lt;/code&gt; are also palindromic subsequences of the given sequence, but not the longest ones.&lt;/p&gt;

&lt;h2 id=&#34;solution-dynamic-programming&#34;&gt;Solution #Dynamic Programming&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static int longestSubsequence(String str) {
		// memo[len][i] represent from index &#39;i&#39; with length &#39;len&#39; has how many
		// palindromic subsequence
		int[][] memo = new int[str.length() + 1][str.length() + 1];

		// initial len with 1 as 1, since for every index it has 1 len
		// palindromic subsequence
		for (int i = 0; i &amp;lt; str.length(); i++)
			memo[1][i] = 1;

		// iterate the str with different length setting
		for (int len = 2; len &amp;lt;= str.length(); len++) {
			for (int i = 0; i &amp;lt;= str.length() - len; i++) {
				int tar = i + len - 1;
				if (len == 2 &amp;amp;&amp;amp; str.charAt(i) == str.charAt(tar))
					memo[len][i] = 2;
				else if (str.charAt(i) == str.charAt(tar))
					memo[len][i] = 2 + memo[len - 2][i + 1];
				else
					memo[len][i] = Math.max(memo[len - 1][i],
							memo[len - 1][i + 1]);
			}
		}
		return memo[str.length()][0];
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-recursive&#34;&gt;Solution # Recursive&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int calculateRecursive(char str[],int start,int len){
        if(len == 1){
            return 1;
        }
        if(len ==0){
            return 0;
        }
        if(str[start] == str[start+len-1]){
            return 2 + calculateRecursive(str,start+1,len-2);
        }else{
            return Math.max(calculateRecursive(str, start+1, len-1), calculateRecursive(str, start, len-1));
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Nim Game</title>
      <link>http://xmxiaohuilin.github.io/2015/11/11/nim-game/</link>
      <pubDate>Wed, 11 Nov 2015 10:43:13 -0700</pubDate>
      
      <guid>http://xmxiaohuilin.github.io/2015/11/11/nim-game/</guid>
      <description>

&lt;p&gt;You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.&lt;/p&gt;

&lt;p&gt;Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.&lt;/p&gt;

&lt;p&gt;For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.&lt;/p&gt;

&lt;h3 id=&#34;hint&#34;&gt;Hint&lt;/h3&gt;

&lt;p&gt;If there are 5 stones in the heap, could you figure out a way to remove the stones such that you will always be the winner?&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Similar with the Coin in A Line I&lt;/li&gt;
&lt;li&gt;The death number will be the multiply of &lt;code&gt;the max amount your can taken +1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;So just check if the total amount is the multiply of &lt;code&gt;4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;proof&#34;&gt;Proof:&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;the base case: when &lt;code&gt;n&lt;/code&gt; = &lt;code&gt;4&lt;/code&gt;, as suggested by the hint from the problem, no matter which number that that first player, the second player would always be able to pick the remaining number.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For &lt;code&gt;1 x 4&lt;/code&gt; &amp;lt; &lt;code&gt;n&lt;/code&gt; &amp;lt; &lt;code&gt;2 x 4&lt;/code&gt;, (&lt;code&gt;n&lt;/code&gt; = &lt;code&gt;5, 6, 7&lt;/code&gt;), the first player can reduce the initial number into 4 accordingly, which will leave the death number 4 to the second player. i.e. The numbers &lt;code&gt;5, 6, 7&lt;/code&gt; are winning numbers for any player who got it first.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now to the beginning of the next cycle, n = 8, no matter which number that the first player picks, it would always leave the winning numbers (5, 6, 7) to the second player. Therefore, &lt;code&gt;8 % 4 == 0&lt;/code&gt;, again is a death number.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Following the second case, for numbers between &lt;code&gt;(2 x 4 = 8)&lt;/code&gt; and &lt;code&gt;(3 x 4=12)&lt;/code&gt;, which are &lt;code&gt;9&lt;/code&gt;,&lt;code&gt;10&lt;/code&gt;, &lt;code&gt;11&lt;/code&gt;, are winning numbers for the first player again, because the first player can always reduce the number into the death number 8.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public boolean canWinNim(int n) {
        return n%4 != 0;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Query Range Sum on Array</title>
      <link>http://xmxiaohuilin.github.io/2015/11/11/query-range-sum-on-array/</link>
      <pubDate>Wed, 11 Nov 2015 10:43:13 -0700</pubDate>
      
      <guid>http://xmxiaohuilin.github.io/2015/11/11/query-range-sum-on-array/</guid>
      <description>

&lt;p&gt;Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example:&lt;/h3&gt;

&lt;p&gt;Given nums = [-2, 0, 3, -5, 2, -1]&lt;/p&gt;

&lt;p&gt;sumRange(0, 2) -&amp;gt; 1
sumRange(2, 5) -&amp;gt; -1
sumRange(0, 5) -&amp;gt; -3
Note:
You may assume that the array does not change.
There are many calls to sumRange function.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Save the prefix sum in extra array.&lt;/li&gt;
&lt;li&gt;Be aware to the &lt;code&gt;sum[0]&lt;/code&gt; means nothing before the first element of input array &lt;code&gt;nums&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;return the the difference on prefix index &lt;code&gt;[high] - [low - 1]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class NumArray {
    int[] sum;
    
    public NumArray(int[] nums) {
        sum = new int[nums.length + 1];
        for(int i = 1; i &amp;lt;= nums.length; i++) {
            sum[i] = nums[i-1] + sum[i-1];
        }
    }

    public int sumRange(int i, int j) {
        return sum[j+1]-sum[i];
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Maximum Subarray III</title>
      <link>http://xmxiaohuilin.github.io/2015/11/07/maximum-subarray-iii/</link>
      <pubDate>Sat, 07 Nov 2015 19:43:13 -0700</pubDate>
      
      <guid>http://xmxiaohuilin.github.io/2015/11/07/maximum-subarray-iii/</guid>
      <description>

&lt;p&gt;Given an array of integers and a number k, find k non-overlapping subarrays which have the largest sum.&lt;/p&gt;

&lt;p&gt;The number in each subarray should be contiguous.&lt;/p&gt;

&lt;p&gt;Return the largest sum.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;[-1,4,-2,3,-2,3]&lt;/code&gt;, k=&lt;code&gt;2&lt;/code&gt;, return &lt;code&gt;8&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;The subarray should contain at least one number&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;State: &lt;code&gt;memo[k][i]&lt;/code&gt; means the max subarray sum value from index 0 to i-1 with taken k subarrays&lt;/li&gt;
&lt;li&gt;Since &lt;code&gt;k&lt;/code&gt; is the amount of subarray, so at least we have to take &lt;code&gt;k&lt;/code&gt; elements in array&lt;/li&gt;
&lt;li&gt;Initilize with two case:

&lt;ul&gt;
&lt;li&gt;Taken first &lt;code&gt;k&lt;/code&gt; elements, each element is a subarray, so we only consider first kth element.&lt;/li&gt;
&lt;li&gt;Taken only one subarray, with two cases: start from previous to current  or start from itself.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;For the rest of elements, consider two cases:

&lt;ul&gt;
&lt;li&gt;Taken from the previous element with no subarray amount increase (&lt;code&gt;memo[k][i-1] + current element&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Taken from current element but increase &lt;code&gt;k&lt;/code&gt; so &lt;code&gt;memo[k-1][n] + current element&lt;/code&gt;, however, here &lt;code&gt;n&lt;/code&gt; can be any number from  &lt;code&gt;k-1&lt;/code&gt; to &lt;code&gt;current index - 1&lt;/code&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param nums: A list of integers
     * @param k: An integer denote to find k non-overlapping subarrays
     * @return: An integer denote the sum of max k non-overlapping subarrays
     */
    public int maxSubArray(ArrayList&amp;lt;Integer&amp;gt; nums, int k) {
        
        // like backpack, memo[k][i] means the max value from index 0 to i-1 with taken k subarray 
        int[][] memo = new int[k+1][nums.size()];
        
        // count previous kth num, which means the each item as a subarray
        for(int i = 1; i&amp;lt;= k; i++) {
            int sum = 0;
            for(int j = 0; j &amp;lt; i; j++) {
                sum += nums.get(j);
            }
            memo[i][i-1] = sum;
        }
        
        // when k = 1, calculate the max value has two choices:
        // 1) max value from previous index (also come from two choices) and current index
        // 2) just start from current index
        for(int i = 1; i &amp;lt; nums.size(); i++) {
            memo[1][i] = Math.max(memo[1][i-1] + nums.get(i), nums.get(i));
        }
        
        // also has two cases: 
        // 1) continous get from previous index to current
        // 2) not continuous but we have to scan each index between current and (k-1) position 
        for(int subarr = 2; subarr &amp;lt;= k; subarr++) {
            for(int j = subarr; j &amp;lt; nums.size(); j++) {
                // 1) continous get so directly add current number
                memo[subarr][j] =  memo[subarr][j-1] + nums.get(j);
                // 2) resume in previous index from subarr - 2 (one more minus for index)
                for(int s = subarr - 2; s &amp;lt; j; s++) {
                    memo[subarr][j] = Math.max(memo[subarr][j], memo[subarr-1][s] + nums.get(j));
                }
            }
        }
        
        // pass through all case from k-1 to array length
        int max = Integer.MIN_VALUE;
        for(int i = k-1; i &amp;lt; nums.size(); i++) {
            max = Math.max(max, memo[k][i]);
        }
        return max;
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Paint House</title>
      <link>http://xmxiaohuilin.github.io/2015/11/07/paint-house/</link>
      <pubDate>Sat, 07 Nov 2015 19:43:13 -0700</pubDate>
      
      <guid>http://xmxiaohuilin.github.io/2015/11/07/paint-house/</guid>
      <description>

&lt;h2 id=&#34;paint-fence&#34;&gt;Paint Fence&lt;/h2&gt;

&lt;p&gt;There is a fence with &lt;code&gt;n&lt;/code&gt; posts, each post can be painted with one of the &lt;code&gt;k&lt;/code&gt; colors.&lt;/p&gt;

&lt;p&gt;You have to paint all the posts such that &lt;strong&gt;no more than two adjacent fence posts&lt;/strong&gt; have the same color.&lt;/p&gt;

&lt;p&gt;Return the total number of ways you can paint the fence.&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;n&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are non-negative integers.&lt;/p&gt;

&lt;h3 id=&#34;think&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Two cases:

&lt;ul&gt;
&lt;li&gt;If &lt;code&gt;[n-1] == [n]&lt;/code&gt;, &lt;code&gt;[n]&lt;/code&gt; has &lt;code&gt;1&lt;/code&gt; choices&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;[n-1] != [n]&lt;/code&gt;, &lt;code&gt;[n]&lt;/code&gt; has &lt;code&gt;k-1&lt;/code&gt; choices with consider the result from both &lt;code&gt;[n-2] == [n-1]&lt;/code&gt; OR &lt;code&gt;[n-2] != [n-1]&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int numWays(int n, int k) {  
        if(n == 0 || k == 0)  
            return 0;  
        int same = k;
        if(n == 1)
            return same;
        int noSame = k*(k-1);
        for(int i = 2; i &amp;lt; n; i++) {
            int tmp = noSame;
            noSame = (same + noSame) * (k-1);
            same = tmp * 1;
        }
        return noSame + same;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;paint-house&#34;&gt;Paint House&lt;/h2&gt;

&lt;p&gt;There are a row of n houses, each house can be painted with one of the three colors: &lt;code&gt;red&lt;/code&gt;, &lt;code&gt;blue&lt;/code&gt; or &lt;code&gt;green&lt;/code&gt;. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.&lt;/p&gt;

&lt;p&gt;The cost of painting each house with a certain color is represented by a &lt;code&gt;n x 3&lt;/code&gt; cost matrix. For example, &lt;code&gt;costs[0][0]&lt;/code&gt; is the cost of painting house 0 with color red; &lt;code&gt;costs[1][2]&lt;/code&gt; is the cost of painting house 1 with color green, and so on&amp;hellip; Find the minimum cost to paint all houses.&lt;/p&gt;

&lt;h3 id=&#34;follow-up-2-colors-k-colors&#34;&gt;Follow Up: 2 Colors -&amp;gt; K Colors&lt;/h3&gt;

&lt;p&gt;There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.&lt;/p&gt;

&lt;p&gt;The cost of painting each house with a certain color is represented by a &lt;code&gt;n x k&lt;/code&gt; cost matrix. For example, &lt;code&gt;costs[0][0]&lt;/code&gt; is the cost of painting house 0 with color 0; &lt;code&gt;costs[1][2]&lt;/code&gt; is the cost of painting house 1 with color 2, and so on… Find the minimum cost to paint all houses.&lt;/p&gt;

&lt;h3 id=&#34;think-1&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Current paint only come from the previous different paint cost&lt;/li&gt;
&lt;li&gt;&lt;code&gt;minCost[i][j] = costs[i][j] + min(minCost[i-1][k])&lt;/code&gt; (k != j)&lt;/li&gt;
&lt;li&gt;We can do it in-place, update the newest value on the original memorized array.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-general-for-two-cases-2-or-k-colors&#34;&gt;Solution (General for Two Cases: 2 or K colors)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; public int minCost(int[][] costs) {
    if (costs == null || costs.length == 0) 
            return 0;
    
    for(int i = 1; i &amp;lt; costs.length; i++) {
        for(int j = 0; j &amp;lt; costs[i].length; j++) {
            int cur = Integer.MIN_VALUE;
            for(int k = 0; j &amp;lt; costs[i].length; k++) {
                if(k == j)
                    continue;
                cur = Math.max(cur, costs[i-1][k] + costs[i][j]);
            }
            costs[i][j] = cur;
        }
    }
    
    int max = 0;
    for(int i = 0; i &amp;lt; costs[costs.length - 1].length; i++)
        max = Math.max(max, costs[costs.length - 1][i]);
    
    return max;
 }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Scramble String</title>
      <link>http://xmxiaohuilin.github.io/2015/11/06/scramble-string/</link>
      <pubDate>Fri, 06 Nov 2015 22:10:29 -0700</pubDate>
      
      <guid>http://xmxiaohuilin.github.io/2015/11/06/scramble-string/</guid>
      <description>

&lt;p&gt;Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.&lt;/p&gt;

&lt;p&gt;Below is one possible representation of s1 = &lt;code&gt;&amp;quot;great&amp;quot;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To scramble the string, we may choose any non-leaf node and swap its two children.&lt;/p&gt;

&lt;p&gt;For example, if we choose the node &amp;ldquo;gr&amp;rdquo; and swap its two children, it produces a scrambled string &lt;code&gt;&amp;quot;rgeat&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We say that &lt;code&gt;&amp;quot;rgeat&amp;quot;&lt;/code&gt; is a scrambled string of &lt;code&gt;&amp;quot;great&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Similarly, if we continue to swap the children of nodes &amp;ldquo;eat&amp;rdquo; and &amp;ldquo;at&amp;rdquo;, it produces a scrambled string &lt;code&gt;&amp;quot;rgtae&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We say that &lt;code&gt;&amp;quot;rgtae&amp;quot;&lt;/code&gt; is a scrambled string of &lt;code&gt;&amp;quot;great&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think-dp-version&#34;&gt;Think - DP Version&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Ignore two situations: both length not equal and the characters not the same&lt;/li&gt;
&lt;li&gt;Two sequence but 3-D memorized array&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memo[i][j][k]&lt;/code&gt; means state: for s1.substring(i, i + k) and s2.substring(j, j + k), if they are scramble string&lt;/li&gt;
&lt;li&gt;Two conditions we can regard as scramble, for range of &lt;code&gt;word1(i -&amp;gt; i+k)&lt;/code&gt; or &lt;code&gt;word2(j -&amp;gt; j+k)&lt;/code&gt;:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i -&amp;gt; i + split&lt;/code&gt; = &lt;code&gt;j -&amp;gt; j + split&lt;/code&gt; (len = split) and &lt;code&gt;split + i -&amp;gt; i + k&lt;/code&gt; = &lt;code&gt;split + i -&amp;gt; j + k&lt;/code&gt; (len = k - split)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i -&amp;gt; i + split&lt;/code&gt; = &lt;code&gt;j + (k - split) -&amp;gt; j+k&lt;/code&gt; [len = split] and &lt;code&gt;i + split -&amp;gt; i+k&lt;/code&gt; = &lt;code&gt;j -&amp;gt; j + (k - split)&lt;/code&gt;(len = k - split)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Consider about the initialization:

&lt;ul&gt;
&lt;li&gt;for &lt;code&gt;k == 1&lt;/code&gt;, we only check if &lt;code&gt;word1[i] == word2[j]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param s1 A string
     * @param s2 Another string
     * @return whether s2 is a scrambled string of s1
     */
    public boolean isScramble(String s1, String s2) {
        // check length
        if(s1==null||s2==null||s1.length()!=s2.length())
            return false;
        // check anagram
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();
        Arrays.sort(c1);
        Arrays.sort(c2);
        if (!Arrays.equals(c1, c2))
			return false;
			
        if(s1.length() != s2.length())
            return false;
        int len = s1.length();
        
        // state: for s1.substring(i, i + k) and s2.substring(j, j + k), if they are scramble string
        boolean[][][] memo = new boolean[len][len][len+1];
        
        // initial, only check if s1[i] == s2[j] 
        for(int i=0;i&amp;lt;s1.length();i++)
            for(int j=0;j&amp;lt;s2.length();j++)
                memo[i][j][1] = (s1.charAt(i) == s2.charAt(j));
                
        for(int k = 2; k &amp;lt;= len; k++) {
            
            for(int i = 0; i &amp;lt;= len - k; i++) {
                for(int j = 0; j &amp;lt;= len - k; j++) {
                    // split point should start from 1 to k - 1
                    for(int split = 1; split &amp;lt; k; split++) {
                        memo[i][j][k] |= (memo[i][j][split]&amp;amp;&amp;amp;memo[i+split][j+split][k-split])||(memo[i][j+(k - split)][split]&amp;amp;&amp;amp;memo[i+split][j][k-split]);
                    }
                }
            }
        }
        return memo[0][0][len];
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Word Break</title>
      <link>http://xmxiaohuilin.github.io/2015/11/06/word-break/</link>
      <pubDate>Fri, 06 Nov 2015 20:10:29 -0700</pubDate>
      
      <guid>http://xmxiaohuilin.github.io/2015/11/06/word-break/</guid>
      <description>

&lt;p&gt;Given a string s and a dictionary of words dict, determine if s can be break into a space-separated sequence of one or more dictionary words.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given s = &lt;code&gt;&amp;quot;lintcode&amp;quot;&lt;/code&gt;, dict = &lt;code&gt;[&amp;quot;lint&amp;quot;, &amp;quot;code&amp;quot;]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Return true because &amp;ldquo;lintcode&amp;rdquo; can be break as &amp;ldquo;lint code&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;One sequence DP, a 1-D boolean array.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memo[i]&lt;/code&gt; means from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;i&lt;/code&gt; has valid word break or not.&lt;/li&gt;
&lt;li&gt;Tricky part is when we pass at &lt;code&gt;i&lt;/code&gt; position, we don&amp;rsquo;t need to use &lt;code&gt;j&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;i&lt;/code&gt; for checking word existed in dictionary. We can use the length of word in dictionary as an length evaluation.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param s: A string s
     * @param dict: A dictionary of words dict
     */
    public boolean wordBreak(String s, Set&amp;lt;String&amp;gt; dict) {
    
        if(s == null || s.length() == 0){
            if(dict == null || dict.size() == 0)
                return true;
            return false;
        }
        
        boolean[] memo = new boolean[s.length() + 1];
        memo[0] = true;
        for(int i = 1; i &amp;lt;= s.length(); i ++) {
            for(String ss : dict){
                int start = i - ss.length();
                if( start &amp;gt;= 0 &amp;amp;&amp;amp; memo[start]){
                    String str = s.substring(start, i);
                    if(dict.contains(str))
                         memo[i] = true;
                }
            }
        }
        return memo[s.length()];
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>House Robber</title>
      <link>http://xmxiaohuilin.github.io/2015/11/06/house-robber/</link>
      <pubDate>Fri, 06 Nov 2015 13:10:29 -0700</pubDate>
      
      <guid>http://xmxiaohuilin.github.io/2015/11/06/house-robber/</guid>
      <description>

&lt;p&gt;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and &lt;strong&gt;it will automatically contact the police if two adjacent houses were broken into on the same night&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;[3, 8, 4]&lt;/code&gt;, return 8.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;$O(n)$ time and $O(1)$ memory.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;When Rob meet a house, he has two choices: taken or not taken, but if he had stolen the previous house, it cannnot taken.&lt;/li&gt;
&lt;li&gt;Set two variable: &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;include&lt;/code&gt; means it has taken the previous house, while the &lt;code&gt;exclude&lt;/code&gt; means it didn&amp;rsquo;t take in previous house.&lt;/li&gt;
&lt;li&gt;So each time we consider about the &lt;code&gt;exclude + cur_value&lt;/code&gt; and &lt;code&gt;include&lt;/code&gt;, the max of them should be new &lt;code&gt;include&lt;/code&gt; while the new &lt;code&gt;exclude&lt;/code&gt; come from the max value of original &lt;code&gt;include&lt;/code&gt; (last taken, current not taken) and original &lt;code&gt;exclude&lt;/code&gt; (not taken in both last and current house)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param A: An array of non-negative integers.
     * return: The maximum amount of money you can rob tonight
     */
    public long houseRobber(int[] A) {
        if(A == null)
            return 0L;
        long exclude = 0L;
        long include = 0L;
        
        for(int i = 0; i &amp;lt; A.length; i++) {
            long tmp = include;
            include = Math.max(include, exclude + A[i]);
            exclude = Math.max(tmp, exclude);
        }
        
        return Math.max(include, exclude);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;follow-up&#34;&gt;Follow Up&lt;/h2&gt;

&lt;p&gt;After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.&lt;/p&gt;

&lt;p&gt;Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/p&gt;

&lt;h3 id=&#34;think-1&#34;&gt;Think&lt;/h3&gt;

&lt;p&gt;The houses are in a cycle,so that when pick up the first element we cannot pick the last element because they are adjacent. So just seperate two parts for calculating: &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;last second element&lt;/code&gt;, and &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;last element&lt;/code&gt;, find the maximum from them.&lt;/p&gt;

&lt;h3 id=&#34;solution-1&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int rob(int[] nums) {
        if(nums==null||nums.length==0)
            return 0;
        if(nums.length==1)
            return nums[0];
        return Math.max(helper(0, nums.length-2, nums), helper(1,nums.length-1,nums));
    }
    
    private int helper(int l, int r, int[] nums){
        if(nums==null||nums.length==0)
            return 0;
        int incl = 0;
        int excl = 0;
        for(int i = l;i&amp;lt;=r;i++){
            int tmp = incl;
            incl = excl+nums[i];
            excl = Math.max(excl, tmp);
        }
        return Math.max(incl, excl);
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Maximal Square</title>
      <link>http://xmxiaohuilin.github.io/2015/11/05/maximal-square/</link>
      <pubDate>Thu, 05 Nov 2015 20:10:29 -0700</pubDate>
      
      <guid>http://xmxiaohuilin.github.io/2015/11/05/maximal-square/</guid>
      <description>

&lt;p&gt;Given a 2D binary matrix filled with 0&amp;rsquo;s and 1&amp;rsquo;s, find the largest square containing all 1&amp;rsquo;s and return its area.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For example, given the following matrix:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1 0 1 0 0
    1 0 1 1 1
    1 1 1 1 1
    1 0 0 1 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Return &lt;code&gt;4&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Use itself as memorized array (modifying value directly on matrix)&lt;/li&gt;
&lt;li&gt;Ignore the top and left boundary&lt;/li&gt;
&lt;li&gt;If current point &lt;code&gt;[i][j]&lt;/code&gt; is one, look up all three directions from &lt;code&gt;[i-1][j]&lt;/code&gt;, &lt;code&gt;[i-1][j-1]&lt;/code&gt; and &lt;code&gt;[i][j-1]&lt;/code&gt; are not zero, get the minimum value from them so that the value plus one is the maximum length of square on current point.&lt;/li&gt;
&lt;li&gt;However, if one of three is zero, current point should keep zero or one&lt;/li&gt;
&lt;li&gt;Set a max value to track the max length.&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t forget make a square on final max result, since that result is just for length&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param matrix: a matrix of 0 and 1
     * @return: an integer
     */
    public int maxSquare(int[][] matrix) {
        if(matrix == null || matrix.length == 0)
            return 0;
        
        int max = 0;
        for(int i = 0; i &amp;lt; matrix.length; i++) {
            for(int j = 0; j &amp;lt; matrix[i].length; j++) {
                if(i != 0 &amp;amp;&amp;amp; j != 0 &amp;amp;&amp;amp; matrix[i][j]!=0 &amp;amp;&amp;amp; matrix[i-1][j] != 0 &amp;amp;&amp;amp; matrix[i][j-1] != 0 &amp;amp;&amp;amp; matrix[i-1][j-1] != 0) 
                    matrix[i][j] = 1 + Math.min(matrix[i-1][j-1],Math.min(matrix[i-1][j],matrix[i][j-1]));
                max = Math.max(max, matrix[i][j]);
            }
        }
        return max*max;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Palindrome Partitioning</title>
      <link>http://xmxiaohuilin.github.io/2015/11/05/palindrome-partitioning/</link>
      <pubDate>Thu, 05 Nov 2015 20:10:29 -0700</pubDate>
      
      <guid>http://xmxiaohuilin.github.io/2015/11/05/palindrome-partitioning/</guid>
      <description>

&lt;h2 id=&#34;problem-i&#34;&gt;Problem I&lt;/h2&gt;

&lt;p&gt;Given a string s, partition s such that every substring of the partition is a palindrome.&lt;/p&gt;

&lt;p&gt;Return all possible palindrome partitioning of &lt;code&gt;s&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;example&#34;&gt;Example&lt;/h4&gt;

&lt;p&gt;Given s = &lt;code&gt;&amp;quot;aab&amp;quot;&lt;/code&gt;, return:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  [&amp;quot;aa&amp;quot;,&amp;quot;b&amp;quot;],
  [&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;think&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Set a boolean matrix for check word segment is prlindrome or not. &lt;code&gt;[i][j]&lt;/code&gt; -&amp;gt; &lt;code&gt;word(i, j)&lt;/code&gt; is palindrome&lt;/li&gt;
&lt;li&gt;DFS to build up all palindrome partition solutions.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param s: A string
     * @return: A list of lists of string
     */
    public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; partition(String s) {
        List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(s == null || s.length() == 0)
            return res;
        // get palindrome boolean matrix [i][j] -&amp;gt; word(i, j) is palindrome
        boolean[][] memo = new boolean[s.length()][s.length()];
        for(int i = s.length() - 1; i &amp;gt;= 0; i--) 
            for(int j = i; j &amp;lt; s.length(); j++) 
                memo[i][j] |= (j - i &amp;lt; 2 || memo[i+1][j-1]) &amp;amp;&amp;amp; s.charAt(i) == s.charAt(j);
        
        // setup dfs method     
        helper(res, new ArrayList&amp;lt;String&amp;gt;(), memo, s, 0);
        return res;
    }
    
    private void helper(List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res, List&amp;lt;String&amp;gt; list, boolean[][] memo, String s, int idx) {
        if(idx &amp;gt;= s.length()) {
            res.add(new ArrayList&amp;lt;&amp;gt;(list));
            return;
        }
        
        for(int i = idx; i &amp;lt; s.length(); i++) {
            if(memo[idx][i]) {
                String substr = s.substring(idx,i+1);
                list.add(substr);
                helper(res, list, memo, s, i+1);
                list.remove(list.size() - 1);
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-ii&#34;&gt;Problem II&lt;/h2&gt;

&lt;p&gt;Given a string s, cut s into some substrings such that every substring is a palindrome.&lt;/p&gt;

&lt;p&gt;Return the &lt;strong&gt;minimum cuts&lt;/strong&gt; needed for a palindrome partitioning of s.&lt;/p&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example&lt;/h4&gt;

&lt;p&gt;For example, given s = &lt;code&gt;&amp;quot;aab&amp;quot;&lt;/code&gt;,&lt;/p&gt;

&lt;p&gt;Return 1 since the palindrome partitioning &lt;code&gt;[&amp;quot;aa&amp;quot;,&amp;quot;b&amp;quot;]&lt;/code&gt; could be produced using 1 cut.&lt;/p&gt;

&lt;h3 id=&#34;think-1&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;First step should be set up boolean matrix for check word segment is prlindrome or not. &lt;code&gt;[i][j]&lt;/code&gt; -&amp;gt; &lt;code&gt;word(i, j)&lt;/code&gt; is palindrome&lt;/li&gt;
&lt;li&gt;Then we need to have a array &lt;code&gt;res[i]&lt;/code&gt; to memorize the minimum cut from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;i&lt;/code&gt; position.&lt;/li&gt;
&lt;li&gt;Initial the first element in memorized array  as &lt;code&gt;0&lt;/code&gt; (no cut needed)&lt;/li&gt;
&lt;li&gt;Pass all position &lt;code&gt;i&lt;/code&gt; from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;When at &lt;code&gt;i&lt;/code&gt; position, we should try &lt;code&gt;j&lt;/code&gt; reversely (avoid update) from &lt;code&gt;j = i&lt;/code&gt; to &lt;code&gt;j = 0&lt;/code&gt; and check if &lt;code&gt;word(j, i-1)&lt;/code&gt; is palindrome.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;word(j, i-1)&lt;/code&gt; is palindrome, and &lt;code&gt;res[j]&lt;/code&gt; has valid minimum cut. Update &lt;code&gt;res[i]&lt;/code&gt; is necessary.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-1&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param s a string
     * @return an integer
     */
    public int minCut(String s) {
        if( s == null || s.length() == 0)
            return 0;
        // step one: boolean matrix for check word segment is prlindrome or not
        boolean[][] memo = new boolean[s.length()][s.length()];
        for(int i = s.length() - 1; i &amp;gt;= 0; i--) 
            for(int j = i; j &amp;lt; s.length(); j++) 
                memo[i][j] |= (j - i &amp;lt; 2 || memo[i+1][j-1]) &amp;amp;&amp;amp; s.charAt(i) == s.charAt(j);
        // step two: cut[i] memorized the minimum cut from `1` to `i` position
        int[] cut = new int[s.length() + 1];
        cut[0] = 0;
        for(int i = 0; i &amp;lt; s.length(); i++) {
            cut[i + 1] = Integer.MAX_VALUE; 
            for(int j = i; j &amp;gt;= 0; j --) {
                cut[i + 1] = memo[j][i] &amp;amp;&amp;amp; cut[j] != Integer.MAX_VALUE ?  Math.min(cut[i+1], cut[j] + 1) : cut[i+1];
            }
        }
        return cut[s.length()] - 1;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Coins in a Line</title>
      <link>http://xmxiaohuilin.github.io/2015/11/05/coins-in-a-line/</link>
      <pubDate>Thu, 05 Nov 2015 13:10:29 -0700</pubDate>
      
      <guid>http://xmxiaohuilin.github.io/2015/11/05/coins-in-a-line/</guid>
      <description>

&lt;h2 id=&#34;problem-i&#34;&gt;Problem I&lt;/h2&gt;

&lt;p&gt;There are n coins in a line. Two players take turns to take one or two coins from right side until there are no more coins left. The player who take the last coin wins.&lt;/p&gt;

&lt;p&gt;Could you please decide the first play will win or lose?&lt;/p&gt;

&lt;h4 id=&#34;example&#34;&gt;Example&lt;/h4&gt;

&lt;p&gt;n = &lt;code&gt;1&lt;/code&gt;, return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;n = &lt;code&gt;2&lt;/code&gt;, return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;n = &lt;code&gt;3&lt;/code&gt;, return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;n = &lt;code&gt;4&lt;/code&gt;, return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;n = &lt;code&gt;5&lt;/code&gt;, return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;challenge&#34;&gt;Challenge&lt;/h4&gt;

&lt;p&gt;$O(n)$ time and $$O(1)$$ memory&lt;/p&gt;

&lt;h3 id=&#34;think&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Only if the amount of coin is the multiply of &lt;code&gt;3&lt;/code&gt;, first player cannot win.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param n: an integer
     * @return: a boolean which equals to true if the first player will win
     */
    public boolean firstWillWin(int n) {
        return n%3!=0;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-ii&#34;&gt;Problem II&lt;/h2&gt;

&lt;p&gt;There are n coins with different value in a line. Two players take turns to take one or two coins from left side until there are no more coins left. The player who take the coins with the most value wins.&lt;/p&gt;

&lt;p&gt;Could you please decide the first player will win or lose?&lt;/p&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example&lt;/h4&gt;

&lt;p&gt;Given values array A = &lt;code&gt;[1,2,2]&lt;/code&gt;, return true.&lt;/p&gt;

&lt;p&gt;Given A = &lt;code&gt;[1,2,4]&lt;/code&gt;, return false.&lt;/p&gt;

&lt;h3 id=&#34;think-1&#34;&gt;Think&lt;/h3&gt;

&lt;h5 id=&#34;state&#34;&gt;State&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;dp[i]&lt;/code&gt; represent the max value it can get from &lt;code&gt;i&lt;/code&gt; to the end&lt;/p&gt;

&lt;h5 id=&#34;function&#34;&gt;Function&lt;/h5&gt;

&lt;p&gt;Each time when iterate &lt;code&gt;i&lt;/code&gt;, we have two choice:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;takes &lt;code&gt;values[i]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;takes &lt;code&gt;values[i] + values[i+1]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here are what we need to think:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.If we took &lt;code&gt;values[i]&lt;/code&gt;, opposite has two choice:  &lt;code&gt;values[i+1]&lt;/code&gt; or &lt;code&gt;values[i+1] + values[i+2]&lt;/code&gt; so the rest values for our own sides are &lt;code&gt;DP[i+2]&lt;/code&gt; or &lt;code&gt;DP[i+3]&lt;/code&gt;, however it should choose the minimum so that the opposite can get the maximum.&lt;/p&gt;

&lt;p&gt;$$value1 = values[i] + min(DP[i+2], DP[i+3])$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2.If we took  &lt;code&gt;values[i] + values[i+1]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;$$value2 = values[i] + values[i+1] + min(DP[i+3], DP[i+4])$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;3.&lt;/p&gt;

&lt;p&gt;$$dp[I] = max(value1, value2)$$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-1&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param values: an array of integers
     * @return: a boolean which equals to true if the first player will win
     */
    public boolean firstWillWin(int[] values) {
        if (values == null || values.length &amp;lt;= 2) {
            return true;
        }
        int dp[] = new int[values.length];
        
        dp[values.length-1] = values[values.length-1];
        dp[values.length-2] = values[values.length-1] + values[values.length-2];
        int total = dp[values.length-2];
        
        for(int i = values.length - 3; i &amp;gt;= 0; i--) {
            total += values[i];
            int value1 = values[i] + Math.min(dp[i+2], i+3&amp;lt;values.length?dp[i+3]:0);
            int value2 = values[i] + values[i+1] + Math.min(i+3&amp;lt;values.length?dp[i+3]:0, i+4&amp;lt;values.length?dp[i+4]:0);
            dp[i] = Math.max(value1, value2);
        }
        
        return dp[0] &amp;gt; (total - dp[0]);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-iii&#34;&gt;Problem III&lt;/h2&gt;

&lt;p&gt;There are n coins in a line. Two players take turns to take a coin from one of the ends of the line until there are no more coins left. The player with the larger amount of money wins.&lt;/p&gt;

&lt;p&gt;Could you please decide the first player will win or lose?&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example&lt;/h4&gt;

&lt;p&gt;Given array A = &lt;code&gt;[3,2,2]&lt;/code&gt;, return true.&lt;/p&gt;

&lt;p&gt;Given array A = &lt;code&gt;[1,2,4]&lt;/code&gt;, return true.&lt;/p&gt;

&lt;p&gt;Given array A = &lt;code&gt;[1,20,4]&lt;/code&gt;, return false.&lt;/p&gt;

&lt;h4 id=&#34;challenge-1&#34;&gt;Challenge&lt;/h4&gt;

&lt;p&gt;Follow Up Question: If &lt;code&gt;n&lt;/code&gt; is even. Is there any hacky algorithm that can decide whether first player will win or lose in $$O(1)$$ memory and $O(n)$ time?&lt;/p&gt;

&lt;h3 id=&#34;think-2&#34;&gt;Think&lt;/h3&gt;

&lt;h5 id=&#34;state-1&#34;&gt;State&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;dp[i][j]&lt;/code&gt; represent the max value it can get from &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;j&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sum[i][j]&lt;/code&gt; represent the sum value from &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;j&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;function-1&#34;&gt;Function&lt;/h5&gt;

&lt;p&gt;Each time when taken coins, we have two choice:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;takes &lt;code&gt;values[i]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;takes &lt;code&gt;values[j]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$dp[i][j]=max(values[i]+sum[i+1][j]-dp[i+1][j], values[j]+sum[i][j-1]-dp[i][j-1])$$&lt;/p&gt;

&lt;p&gt;Since &lt;code&gt;values[i]+sum[i+1][j]&lt;/code&gt; or &lt;code&gt;values[j]+sum[i][j-1]&lt;/code&gt; equals to &lt;code&gt;sum[i][j]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So the equation can be $dp[i][j] = sum[i][j] - min(dp[i+1][j],dp[i][j-1])$&lt;/p&gt;

&lt;h3 id=&#34;solution-2&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param values: an array of integers
     * @return: a boolean which equals to true if the first player will win
     */
    public boolean firstWillWin(int[] values) {
        if (values == null || values.length &amp;lt;= 2) {
            return true;
        }
        
        int[][] dp = new int[values.length][values.length];
        int[][] sum = new int[values.length][values.length];
        // get the sum of i to j
        for(int i = 0; i &amp;lt; values.length; i++){
            for(int j  = i; j &amp;lt; values.length; j++) {
                if(i == j)
                    sum[i][j] = values[i];
                else
                    sum[i][j] = values[j] + sum[i][j-1];
            }
        }
        
        // to do the dp 
        for(int i = values.length - 1; i &amp;gt;= 0; i--){
            for(int j  = i; j &amp;lt; values.length; j++) {
                if(i == j)
                    dp[i][j] = values[i];
                else
                    dp[i][j] = sum[i][j] - Math.min(dp[i+1][j],dp[i][j-1]);
            }
        }
        
        return dp[0][values.length - 1] &amp;gt; sum[0][values.length - 1] - dp[0][values.length - 1];
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Distinct Subsequences</title>
      <link>http://xmxiaohuilin.github.io/2015/11/05/distinct-subsequences/</link>
      <pubDate>Thu, 05 Nov 2015 13:10:29 -0700</pubDate>
      
      <guid>http://xmxiaohuilin.github.io/2015/11/05/distinct-subsequences/</guid>
      <description>

&lt;p&gt;Given a string S and a string T, count the number of distinct subsequences of T in S.&lt;/p&gt;

&lt;p&gt;A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &amp;ldquo;ACE&amp;rdquo; is a subsequence of &amp;ldquo;ABCDE&amp;rdquo; while &amp;ldquo;AEC&amp;rdquo; is not).&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given S = &amp;ldquo;rabbbit&amp;rdquo;, T = &amp;ldquo;rabbit&amp;rdquo;, return 3.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Do it in $O(n^2)$ time and $O(n)$ memory.&lt;/p&gt;

&lt;p&gt;$O(n^2)$ memory is also acceptable if you do not know how to optimize memory.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Two sequence DP, setup 2-D array for memorizing&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][j]&lt;/code&gt; means the distinct count when &lt;code&gt;S(1,i)&lt;/code&gt; and &lt;code&gt;T(1,j)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If S has non character &lt;code&gt;dp[0][j]&lt;/code&gt; should be 0, while T has non character &lt;code&gt;dp[i][0]&lt;/code&gt; should be 1.&lt;/li&gt;
&lt;li&gt;Each time we add &lt;code&gt;S[i]&lt;/code&gt; on &lt;code&gt;dp[i-1][j]&lt;/code&gt;, iterate &lt;code&gt;j&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;len - 1&lt;/code&gt;, if &lt;code&gt;S[i] == T[j]&lt;/code&gt; we should look up the the result from &lt;code&gt;dp[i-1][j-1]&lt;/code&gt; and add it on &lt;code&gt;dp[i-1][j]&lt;/code&gt;, otherwise we add nothing.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param S, T: Two string.
     * @return: Count the number of distinct subsequences
     */
    public int numDistinct(String S, String T) {
        int[][] memo = new int[S.length() + 1][T.length() + 1];
        for(int i = 0; i &amp;lt;= S.length(); i++) {
            for(int j = 0; j &amp;lt;= T.length(); j++) {
                if(i == 0)
                    memo[i][j] = 0;
                if(j == 0)
                    memo[i][j] = 1;
                else{
                    memo[i][j] = memo[i-1][j] + (S.charAt(i-1) == T.charAt(j-1)) ? memo[i-1][j-1] : 0;
                }
            }
        }
        return memo[S.length()][T.length()];
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Minimum Adjustment Cost</title>
      <link>http://xmxiaohuilin.github.io/2015/11/04/minimum-adjustment-cost/</link>
      <pubDate>Wed, 04 Nov 2015 17:10:29 -0700</pubDate>
      
      <guid>http://xmxiaohuilin.github.io/2015/11/04/minimum-adjustment-cost/</guid>
      <description>

&lt;p&gt;Given an integer array, adjust each integers so that the difference of every adjacent integers are not greater than a given number target.&lt;/p&gt;

&lt;p&gt;If the array before adjustment is A, the array after adjustment is &lt;code&gt;B&lt;/code&gt;, you should minimize the sum of &lt;code&gt;|A[i]-B[i]|&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;[1,4,2,3]&lt;/code&gt; and target = 1, one of the solutions is &lt;code&gt;[2,3,2,3]&lt;/code&gt;, the adjustment cost is 2 and it&amp;rsquo;s minimal.&lt;/p&gt;

&lt;p&gt;Return &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note
You can assume each number in the array is a positive integer and not greater than &lt;code&gt;100&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;There is invisible condition on Note part: each number in the array is a positive integer and not greater than &lt;code&gt;100&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;So the above condition giving the memorized data structure a length on enumeration.&lt;/li&gt;
&lt;li&gt;memo data should be &lt;code&gt;memo[arr.size() + 1][100]&lt;/code&gt;, which means the minimum cost on modify the ith num in A to &lt;code&gt;j&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Pass each element in input array&lt;/li&gt;
&lt;li&gt;Then enumeration &lt;code&gt;j&lt;/code&gt; on 0 to 99, so that we can consider the previous number &lt;code&gt;p&lt;/code&gt; should inside the range between &lt;code&gt;j + target&lt;/code&gt; and &lt;code&gt;j-target&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;So the previous cost should be &lt;code&gt;memo[i-1][p]&lt;/code&gt;and for current, it should be &lt;code&gt;memo[i-1][p] + Math.abs(j-A.get(i-1))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;After arrived the last element and got all possible cost, the minimum total cost should come from &lt;code&gt;memo[last element][i]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param A: An integer array.
     * @param target: An integer.
     */
    public int MinAdjustmentCost(ArrayList&amp;lt;Integer&amp;gt; A, int target) {
        // the minimum cost on modify the ith num in A to j 
        int[][] memo = new int[A.size() + 1][100];
        
        for(int i = 1; i &amp;lt;= A.size(); i++) {
            // enumeration on 0 to 99 
            for(int j=0; j&amp;lt;=99; j++) {
                // initial the minimum cost on ith as the Integer.MAX
                memo[i][j] = Integer.MAX_VALUE;
                // get the range by target based on j 
                int lowerRange = Math.max(0, j-target);
                int upperRange = Math.min(99, j+target);
                // p is the possible num based on previous index
                // check all cost between current index on A and j
                for (int p=lowerRange; p&amp;lt;=upperRange; p++) {
                    
                    memo[i][j] = Math.min(memo[i][j], memo[i-1][p]+Math.abs(j-A.get(i-1)));
                }
            }
        }
        int minCost = Integer.MAX_VALUE;
        // check all minimum cost on index equal to A&#39;s last element
        for(int i = 0; i &amp;lt;= 99; i++)
            minCost = Math.min(minCost, memo[A.size()][i]);
        return minCost;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Longest Increasing Subsequence</title>
      <link>http://xmxiaohuilin.github.io/2015/11/04/longest-increasing-subsequence/</link>
      <pubDate>Wed, 04 Nov 2015 13:10:29 -0700</pubDate>
      
      <guid>http://xmxiaohuilin.github.io/2015/11/04/longest-increasing-subsequence/</guid>
      <description>

&lt;p&gt;Given an unsorted array of integers, find the length of longest increasing sub-sequence.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;[10, 9, 2, 5, 3, 7, 101, 18]&lt;/code&gt;,
The longest increasing sub-sequence is &lt;code&gt;[2, 3, 7, 101]&lt;/code&gt;, therefore the length is &lt;code&gt;4&lt;/code&gt;. Note that there may be more than one LIS combination, it is only necessary for you to return the length.&lt;/p&gt;

&lt;p&gt;Your algorithm should run in $$O(n^2)$$ complexity.&lt;/p&gt;

&lt;h3 id=&#34;follow-up&#34;&gt;Follow up&lt;/h3&gt;

&lt;p&gt;Improve it to O(n log n) time complexity?&lt;/p&gt;

&lt;h2 id=&#34;think-1&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Setup one dimensional array to memorize the longest sub-sequence on each element&lt;/li&gt;
&lt;li&gt;One pass on each element,&lt;/li&gt;
&lt;li&gt;But it need to go through the previous indexes to check any elements less than current element and compare the maximum by &lt;code&gt;max(current, prev +1)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param nums: The integer array
     * @return: The length of LIS (longest increasing subsequence)
     */
    public int longestIncreasingSubsequence(int[] nums) {
        if(nums == null || nums.length == 0)
            return 0;
        int[] memo = new int[nums.length];
        int max = 0;
        for(int i = 0; i &amp;lt; nums.length; i ++) {
            memo[i] = 1;
            for(int j = 0; j &amp;lt; i; j++) {
                if(nums[j] &amp;lt; nums[i]) {
                    memo[i] = Math.max(memo[i], memo[j] + 1);
                }
                max = Math.max(memo[i], max);
            }
        }
        return max;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-2&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Setup an array &lt;code&gt;table&lt;/code&gt; with the length of &lt;code&gt;nums&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;One pass on each element and initial max cursor is &lt;code&gt;0&lt;/code&gt; in &lt;code&gt;table&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Replace the element in &lt;code&gt;table&lt;/code&gt; is just larger than current passing element&lt;/li&gt;
&lt;li&gt;If current element is largest, increase the cursor in &lt;code&gt;table&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Finally, the the cursor + 1 is the max length.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-2&#34;&gt;Solution #2&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param nums: The integer array
     * @return: The length of LIS (longest increasing subsequence)
     */
    public int longestIncreasingSubsequence(int[] nums) {
        if(nums == null || nums.length == 0)
            return 0;
        int[] memo = new int[nums.length];
        int max = 0;
        memo[0] = nums[0];
        for(int i = 1; i &amp;lt; nums.length; i++) {
            if(nums[i] &amp;lt; memo[0])
                memo[0] = nums[i];
            else if(memo[max] &amp;lt;= nums[i])
                memo[++max] = nums[i];
            else{
                int idx = findCeil(memo, max, nums[i]);
                memo[idx] = nums[i];
            }
        }
        return ++max;
    }
    
    /**
     * @param arr: the memo array
     * @param right index: current max in the memo array
     * @param val: target value
     * @return: where should val put in memo array
     */
    private int findCeil(int[] arr, int r, int val){
        int l = 0;
        while(l + 1 &amp;lt; r) {
            int m = l + ((r - l)&amp;gt;&amp;gt;1);
            if(arr[m] &amp;lt; val)
                l = m;
            else
                r = m;
        }
        return r;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>